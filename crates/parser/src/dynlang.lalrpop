use std::string::String;
use crate::lexer::{Token, LexError};
use crate::ast::*;
use tap::Tap;

grammar;

// macros
Separated<T, U>: Vec<T> = ((<T> U)* T)? => <>.map(|(v, l)| v.tap_mut(|v| v.push(l))).unwrap_or(vec![]);

// nil
Nil: Nil = "nil" => Nil;

// bool
Boolean: Boolean = {
	"true" => Boolean(true),
	"false" => Boolean(false),
};

// int
Integer: Integer = "int" => Integer(<>);

// string
StringT: StringT = "string" => StringT(<>);

// literal
Literal: Literal = {
	Nil => Literal::Nil(<>),
	Boolean => Literal::Boolean(<>),
	Integer => Literal::Integer(<>),
	StringT => Literal::String(<>),
};

// identifier
Ident: Ident = "ident" => Ident(<>);

// atom
L0: Expr = {
	Literal => Expr::Literal(<>),
	Ident => Expr::Ident(<>),
	"(" <Expr> ")" => <>,
	"[" <Separated<Expr, ",">> "]" => Expr::Array(Array(Code(<>))),
};

L1: Expr = {
	<L1> "[" <Expr> "]" => Expr::BinExpr(BinExpr::index_box(<>)),
	<i:L1> "(" <args:Separated<Expr, ",">> ")" => Expr::BinExpr(BinExpr::call_box(i, Code(args))),
	L0 => <>,
}
	
L2: Expr = {
	"-" <L2> => Expr::unary_minus_box(<>),
	"!" <L2> => Expr::unary_not_box(<>),
	L1 => <>,
}

L3: Expr = {
	<L3> "*" <L2> => Expr::BinExpr(BinExpr::mul_box(<>)),
	<L3> "/" <L2> => Expr::BinExpr(BinExpr::div_box(<>)),
	<L3> "%" <L2> => Expr::BinExpr(BinExpr::mod_box(<>)),
	L2 => <>,
}

L4: Expr = {
	<L4> "+" <L3> => Expr::BinExpr(BinExpr::add_box(<>)),
	<L4> "-" <L3> => Expr::BinExpr(BinExpr::sub_box(<>)),
	L3 => <>,
};

L5: Expr = {
	<L5> "==" <L4> => Expr::BinExpr(BinExpr::equal_box(<>)),
	<L5> "!=" <L4> => Expr::BinExpr(BinExpr::not_equal_box(<>)),
	<L5> "<" <L4> => Expr::BinExpr(BinExpr::less_than_box(<>)),
	<L5> "<=" <L4> => Expr::BinExpr(BinExpr::less_than_equal_box(<>)),
	<L5> ">" <L4> => Expr::BinExpr(BinExpr::greater_than_box(<>)),
	L4 => <>,
};

L6: Expr = {
	<L6> "&&" <L5> => Expr::BinExpr(BinExpr::and_box(<>)),
	L5 => <>,
};

L7: Expr = {
	<L7> "||" <L6> => Expr::BinExpr(BinExpr::or_box(<>)),
	L6 => <>,
};

L8: Expr = {
	"let" <i:Ident> "=" <e:L7> => Expr::Declare(i, Box::new(e)),
	L7 => <>,
};

pub Expr: Expr = {
	L8 => <>,
}

extern {
	type Location = usize;
	type Error = LexError;

	enum Token {
		"+" => Token::Plus,
		"-" => Token::Minus,
		"*" => Token::Asterisk,
		"/" => Token::Slash,
		"%" => Token::Percent,
		"=" => Token::Assign,
		"+=" => Token::PlusAssign,
		"-=" => Token::MinusAssign,
		"*=" => Token::AsteriskAssign,
		"/=" => Token::SlashAssign,
		"%=" => Token::PercentAssign,
		"==" => Token::Equal,
		"!=" => Token::NotEqual,
		"<" => Token::LeftAngledBracket,
		">" => Token::RightAngledBracket,
		"<=" => Token::LessThanEqual,
		">=" => Token::GreaterThanEqual,
		"&&" => Token::DoubleAnd,
		"||" => Token::DoublePipe,
		"(" => Token::LeftParenthesis,
		")" => Token::RightParenthesis,
		"{" => Token::LeftBrace,
		"}" => Token::RightBrace,
		"[" => Token::LeftBracket,
		"]" => Token::RightBracket,
		"!" => Token::Bang,
		"." => Token::Dot,
		"," => Token::Comma,
		"@" => Token::At,
		"->" => Token::Arrow,
		"nil" => Token::Nil,
		"true" => Token::True,
		"false" => Token::False,
		"panic" => Token::Panic,
		"assert" => Token::Assert,
		"let" => Token::Let,
		"let!" => Token::LetMut,
		"if" => Token::If,
		"else" => Token::Else,
		"iter" => Token::Iter,
		"of" => Token::Of,
		"return" => Token::Return,
		"break" => Token::Break,
		"continue" => Token::Continue,
		"import" => Token::Import,
		"export" => Token::Export,
		"newline" => Token::NewLine,
		"lcomment" => Token::LineComment,
		"bcomment" => Token::BlockCommnet,
		"int" => Token::Integer(<i32>),
		"string" => Token::String(<String>),
		"ident" => Token::Identifier(<String>),
	}
}


